http://os.51cto.com/art/201410/455970.htm
iptables/Netfilter对应的就是tc/TC。

先说Netfilter，无疑这个框架被设计用来在网络协议栈的内核路径上过滤数据包，就像在一条路上的关卡一样，Netfilter在协议栈处理网络数据包的路径上的5个位置设置了这样的关卡，一个数据包在被处理的路径上经过这些关卡被检查，结果就是若干个动作：接受，丢弃，排队，导入其它路径等，框架只需针对一个数据包得出一个结果即可，关卡内部提供什么服务在Netfilter框架中并没有任何规定。
现在我们看TC，它旨在对数据包或者数据流提供一种服务，比如限速，整形等，而这并不是一个类似Netfilter的结果可以表达的，提供这些服务需要执行一系列的动作，因此如何来“规划和组织这些动作的执行”是TC框架设计的关键！也就是说，TC框架关注的是如何执行而不是仅仅想要得到一个要执行的动作。换句话说，Netfilter框架关键做什么，而TC框架关注怎么做。(关于Netfilter我已经写了大量的代码和文章，不再赘述了...)
有关限速，流量整形方面的理论已经很多了，比较常见的比如使用令牌桶，但是本文关注的是Linux对TC框架的实现而不是令牌桶算法相关的内容，然而在一篇短文中又不可能详细描述从流量控制理论到各种操作系统版本实现的历史，但是我们知道，使用队列是大多数实现中实际的选择，那么现在问题来了，Linux 的TC框架是如何组织队列的。在详细深入讨论队列组织之前，我最后一次比较一下Netfilter和TC。
如果你知道UNIX的字符设备和块设备之间的区别，那么理解Netfilter框架和TC框架之间的区别就比较容易了。Netfilter的一个HOOK 点类似一个管道字符设备，而skb就是这个设备中的单向字符流，一般都是按照从一端流入，然后按照进入的顺序从另一端流出，附带一个结果，比如 ACCEPT，DROP等。而TC框架比较类似一个块设备，对内容进行随机存储和随机访问，即skb进入的顺序并不一定是skb出来的顺序，而这正是流量整形需要做的。也就是说，TC框架必须实现一个随机访问的数据包存储缓冲区，在这个缓冲区中进行流量控制，当然，我们已经知道，这是由队列实现的。
当然，任何事情都不是绝对的，Netfilter的一个HOOK点也可以有存储缓冲区或者执行一系列的动作，典型的就是conntrack中的分片重组以及NAT功能，对于PREROUTING这个HOOK点的分片重组，无疑对于分片而言，只是进入HOOK，暂时保存在里面，直到所有分片都来了切重组成功后才一次性流出这个HOOK点，而对于NAT而言，Netfilter的处理结果无疑是“执行了一系列的动作”而不仅仅是ACCEPT。此外，我也写过一些模块，用Netfilter来实现流量控制，反过来，TC框架也可以实现Netfilter的功能，总之，当你理解了这些框架的设计原则以及其本质后，在使用和扩展上，你就可以庖丁解牛，游刃有余了。
个人觉得，对于单独的一个Netfilter HOOK点，TC框架是其超集，实现上更加灵活，当然也就更加复杂。Netfilter所拥有的TC不具备的魅力在于其HOOK点位置的定义。
